#!/usr/bin/env ruby
require 'rubygems'
require 'bundler/setup'
require 'pi_piper'
require 'pry'

PINS=[26, 13, 23, 24, 27, 6, 5, 12, 22, 17].map do |pin|
  PiPiper::Pin.new pin: pin, direction: :out, invert: true
end

# Map:
# 12 24 22 27 17
# 26  6 13  5 23

def noir
  all_on
  loop do
    light = random_light
    rand(3..5).times do
      blink_duration = rand(0.05..0.3)
      puts "Blinking #{light.pin} for #{blink_duration}"
      off light
      sleep blink_duration
      on light
      sleep blink_duration
    end
    sleep rand(5..30)
  end
ensure
  all_off
end

def chase(speed = 0.9)
  min_speed = 0.01
  max_speed = 0.97
  all_off
  delay = 1.0 - [max_speed, [speed, min_speed].max].min
  puts "Delay: #{delay}"
  loop do
    [PINS[0, 5], PINS[5, 9].reverse].flatten.each do |light|
      on light
      sleep delay
      off light
    end
  end
ensure
  all_off
end
    

def all_off
  all(false)
end

def all_on
  all(true)
end

def random_light
  PINS.sample
end

def all(toggle)
  PINS.map{|pin| toggle ? on(pin) : off(pin) }
end

def on(light)
  # Logic is reversed because low == "on"
  puts "ON: #{light.pin}"
  light.off
end

def off(light)
  # Logic is reversed because low == "on"
  puts "OFF: #{light.pin}"
  light.on
end

#while true
#  [5, 4].each {|pin| PINS[pin].off}
#  sleep 0.1
#  [0, 9].each {|pin| PINS[pin].off}
#  sleep 0.1
#  [1, 8].each {|pin| PINS[pin].off}
#  sleep 0.1
#  [7, 2].each {|pin| PINS[pin].off}
#  sleep 0.1
#  [3, 6].each {|pin| PINS[pin].off}
#  sleep 1
#
#  [3, 6].each {|pin| PINS[pin].on}
#  sleep 0.1
#  [7, 2].each {|pin| PINS[pin].on}
#  sleep 0.1
#  [1, 8].each {|pin| PINS[pin].on}
#  sleep 0.1
#  [0, 9].each {|pin| PINS[pin].on}
#  sleep 0.1
#  [5, 4].each {|pin| PINS[pin].on}
#  sleep 3
#end


begin
  binding.pry
ensure
  all_off
end
